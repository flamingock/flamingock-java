/*
 * Copyright 2025 Flamingock (https://www.flamingock.io)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.flamingock.store.sql.internal;

import io.flamingock.internal.common.sql.AbstractSqlDialectHelper;
import io.flamingock.internal.common.sql.SqlDialect;

import javax.sql.DataSource;

public final class SqlAuditorDialectHelper extends AbstractSqlDialectHelper {

    public SqlAuditorDialectHelper(DataSource dataSource) {
        super(dataSource);
    }

    public SqlAuditorDialectHelper(SqlDialect dialect) {
        super(dialect);
    }

    public String getCreateTableSqlString(String tableName) {
        switch (sqlDialect) {
            case MYSQL:
            case MARIADB:
            case H2:
                return String.format(
                        "CREATE TABLE IF NOT EXISTS %s (" +
                                "id %s PRIMARY KEY, " +
                                "execution_id VARCHAR(255), " +
                                "stage_id VARCHAR(255), " +
                                "change_id VARCHAR(255), " +
                                "author VARCHAR(255), " +
                                "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, " +
                                "state VARCHAR(255), " +
                                "invoked_class VARCHAR(255), " +
                                "invoked_method VARCHAR(255), " +
                                "source_file VARCHAR(255), " +
                                "metadata %s, " +
                                "execution_millis %s, " +
                                "execution_hostname VARCHAR(255), " +
                                "error_trace %s, " +
                                "type VARCHAR(50), " +
                                "tx_strategy VARCHAR(50), " +
                                "target_system_id VARCHAR(255), " +
                                "change_order VARCHAR(50), " +
                                "recovery_strategy VARCHAR(50), " +
                                "transaction_flag %s, " +
                                "system_change %s, " +
                                "legacy %s" +
                                ")", tableName, getAutoIncrementType(), getClobType(), getBigIntType(), getClobType(), getBooleanType(), getBooleanType(), getBooleanType());
            case FIREBIRD:
                return String.format(
                        "CREATE TABLE %s (" +
                                "id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, " +
                                "execution_id VARCHAR(255), " +
                                "stage_id VARCHAR(255), " +
                                "change_id VARCHAR(255), " +
                                "author VARCHAR(255), " +
                                "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, " +
                                "state VARCHAR(255), " +
                                "invoked_class VARCHAR(255), " +
                                "invoked_method VARCHAR(255), " +
                                "source_file VARCHAR(255), " +
                                "metadata BLOB SUB_TYPE TEXT, " +
                                "execution_millis BIGINT, " +
                                "execution_hostname VARCHAR(255), " +
                                "error_trace BLOB SUB_TYPE TEXT, " +
                                "type VARCHAR(50), " +
                                "tx_strategy VARCHAR(50), " +
                                "target_system_id VARCHAR(255), " +
                                "change_order VARCHAR(50), " +
                                "recovery_strategy VARCHAR(50), " +
                                "transaction_flag SMALLINT, " +
                                "system_change SMALLINT, " +
                                "legacy SMALLINT" +
                                ")", tableName);
            case POSTGRESQL:
                return String.format(
                        "CREATE TABLE IF NOT EXISTS %s (" +
                                "id SERIAL PRIMARY KEY," +
                                "execution_id VARCHAR(255)," +
                                "stage_id VARCHAR(255)," +
                                "change_id VARCHAR(255)," +
                                "author VARCHAR(255)," +
                                "created_at TIMESTAMP," +
                                "state VARCHAR(32)," +
                                "invoked_class VARCHAR(255)," +
                                "invoked_method VARCHAR(255)," +
                                "source_file VARCHAR(255)," +
                                "metadata TEXT," +
                                "execution_millis BIGINT," +
                                "execution_hostname VARCHAR(255)," +
                                "error_trace TEXT," +
                                "type VARCHAR(32)," +
                                "tx_strategy VARCHAR(32)," +
                                "target_system_id VARCHAR(255)," +
                                "change_order VARCHAR(255)," +
                                "recovery_strategy VARCHAR(32)," +
                                "transaction_flag BOOLEAN," +
                                "system_change BOOLEAN," +
                                "legacy BOOLEAN" +
                                ")", tableName);

            case SQLSERVER:
                return String.format(
                        "IF NOT EXISTS (SELECT * FROM sysobjects WHERE name='%s' AND xtype='U') " +
                                "CREATE TABLE %s (" +
                                "id %s PRIMARY KEY, " +
                                "execution_id VARCHAR(255), " +
                                "stage_id VARCHAR(255), " +
                                "change_id VARCHAR(255), " +
                                "author VARCHAR(255), " +
                                "created_at DATETIME DEFAULT GETDATE(), " +
                                "state VARCHAR(255), " +
                                "invoked_class VARCHAR(255), " +
                                "invoked_method VARCHAR(255), " +
                                "source_file VARCHAR(255), " +
                                "metadata %s, " +
                                "execution_millis %s, " +
                                "execution_hostname VARCHAR(255), " +
                                "error_trace %s, " +
                                "type VARCHAR(50), " +
                                "tx_strategy VARCHAR(50), " +
                                "target_system_id VARCHAR(255), " +
                                "change_order VARCHAR(50), " +
                                "recovery_strategy VARCHAR(50), " +
                                "transaction_flag %s, " +
                                "system_change %s, " +
                                "legacy %s" +
                                ")", tableName, tableName, getAutoIncrementType(), getClobType(), getBigIntType(), getClobType(), getBooleanType(), getBooleanType(), getBooleanType());
            case SYBASE:
                return String.format(
                        "IF NOT EXISTS (SELECT 1 FROM sysobjects WHERE name='%s' AND type='U') " +
                                "BEGIN " +
                                "   EXEC('CREATE TABLE %s (" +
                                "       id BIGINT IDENTITY PRIMARY KEY, " +
                                "       execution_id VARCHAR(255), " +
                                "       stage_id VARCHAR(255), " +
                                "       change_id VARCHAR(255), " +
                                "       author VARCHAR(255), " +
                                "       created_at DATETIME, " +
                                "       state VARCHAR(32), " +
                                "       invoked_class VARCHAR(255), " +
                                "       invoked_method VARCHAR(255), " +
                                "       source_file VARCHAR(255), " +
                                "       metadata TEXT, " +
                                "       execution_millis BIGINT, " +
                                "       execution_hostname VARCHAR(255), " +
                                "       error_trace TEXT, " +
                                "       type VARCHAR(64), " +
                                "       tx_strategy VARCHAR(64), " +
                                "       target_system_id VARCHAR(255), " +
                                "       change_order VARCHAR(255), " +
                                "       recovery_strategy VARCHAR(64), " +
                                "       transaction_flag BIT NOT NULL, " +
                                "       system_change BIT NOT NULL, " +
                                "       legacy BIT NOT NULL" +
                                "   )') " +
                                "END",
                        tableName, tableName
                );
            case ORACLE:
                return String.format(
                        "BEGIN EXECUTE IMMEDIATE 'CREATE TABLE %s (" +
                                "id %s PRIMARY KEY, " +
                                "execution_id VARCHAR2(255), " +
                                "stage_id VARCHAR2(255), " +
                                "change_id VARCHAR2(255), " +
                                "author VARCHAR2(255), " +
                                "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, " +
                                "state VARCHAR2(255), " +
                                "invoked_class VARCHAR2(255), " +
                                "invoked_method VARCHAR2(255), " +
                                "source_file VARCHAR2(255), " +
                                "metadata %s, " +
                                "execution_millis %s, " +
                                "execution_hostname VARCHAR2(255), " +
                                "error_trace %s, " +
                                "type VARCHAR2(50), " +
                                "tx_strategy VARCHAR2(50), " +
                                "target_system_id VARCHAR2(255), " +
                                "change_order VARCHAR2(50), " +
                                "recovery_strategy VARCHAR2(50), " +
                                "transaction_flag %s, " +
                                "system_change %s, " +
                                "legacy %s" +
                                ")'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;", tableName, getAutoIncrementType(), getClobType(), getBigIntType(), getClobType(), getBooleanType(), getBooleanType(), getBooleanType());
            case DB2:
                return String.format(
                        "BEGIN\n" +
                                "  DECLARE CONTINUE HANDLER FOR SQLSTATE '42710' BEGIN END;\n" +
                                "  EXECUTE IMMEDIATE 'CREATE TABLE %s (" +
                                "id BIGINT NOT NULL GENERATED ALWAYS AS IDENTITY (START WITH 1, INCREMENT BY 1) PRIMARY KEY," +
                                "execution_id VARCHAR(255)," +
                                "stage_id VARCHAR(255)," +
                                "change_id VARCHAR(255)," +
                                "author VARCHAR(255)," +
                                "created_at TIMESTAMP," +
                                "state VARCHAR(32)," +
                                "invoked_class VARCHAR(255)," +
                                "invoked_method VARCHAR(255)," +
                                "source_file VARCHAR(255)," +
                                "metadata CLOB," +
                                "execution_millis BIGINT," +
                                "execution_hostname VARCHAR(255)," +
                                "error_trace CLOB," +
                                "type VARCHAR(50)," +
                                "tx_strategy VARCHAR(50)," +
                                "target_system_id VARCHAR(255)," +
                                "change_order VARCHAR(50)," +
                                "recovery_strategy VARCHAR(50)," +
                                "transaction_flag SMALLINT," +
                                "system_change SMALLINT," +
                                "legacy SMALLINT" +
                                ")';\n" +
                                "END",
                        tableName);

            case SQLITE:
                return String.format(
                        "CREATE TABLE IF NOT EXISTS %s (" +
                                "id INTEGER PRIMARY KEY, " +
                                "execution_id TEXT, " +
                                "stage_id TEXT, " +
                                "change_id TEXT, " +
                                "author TEXT, " +
                                "created_at DATETIME, " +
                                "state TEXT, " +
                                "invoked_class TEXT, " +
                                "invoked_method TEXT, " +
                                "source_file TEXT, " +
                                "metadata TEXT, " +
                                "execution_millis INTEGER, " +
                                "execution_hostname TEXT, " +
                                "error_trace TEXT, " +
                                "type TEXT, " +
                                "tx_strategy TEXT, " +
                                "target_system_id TEXT, " +
                                "change_order TEXT, " +
                                "recovery_strategy TEXT, " +
                                "transaction_flag INTEGER, " +
                                "system_change INTEGER, " +
                                "legacy INTEGER" +
                                ")", tableName);
            case INFORMIX:
                return String.format(
                        "CREATE TABLE IF NOT EXISTS %s (" +
                                "id SERIAL8 PRIMARY KEY, " +
                                "execution_id VARCHAR(100), " +
                                "stage_id VARCHAR(100), " +
                                "change_id VARCHAR(100), " +
                                "author VARCHAR(100), " +
                                "created_at DATETIME YEAR TO FRACTION(3) DEFAULT CURRENT YEAR TO FRACTION(3), " +
                                "state VARCHAR(50), " +
                                "invoked_class VARCHAR(200), " +
                                "invoked_method VARCHAR(100), " +
                                "source_file VARCHAR(200), " +
                                "metadata LVARCHAR(8000), " +
                                "execution_millis BIGINT, " +
                                "execution_hostname VARCHAR(100), " +
                                "error_trace LVARCHAR(8000), " +
                                "type VARCHAR(50), " +
                                "tx_strategy VARCHAR(50), " +
                                "target_system_id VARCHAR(100), " +
                                "change_order VARCHAR(50), " +
                                "recovery_strategy VARCHAR(50), " +
                                "transaction_flag BOOLEAN, " +
                                "system_change BOOLEAN, " +
                                "legacy BOOLEAN" +
                                ")", tableName);


            default:
                throw new UnsupportedOperationException("Dialect not supported for CREATE TABLE: " + sqlDialect.name());
        }
    }

    public String getInsertSqlString(String tableName) {
        return String.format(
                "INSERT INTO %s (" +
                        "execution_id, stage_id, change_id, author, created_at, state, invoked_class, invoked_method, source_file, metadata, " +
                        "execution_millis, execution_hostname, error_trace, type, tx_strategy, target_system_id, change_order, recovery_strategy, transaction_flag, system_change, legacy" +
                        ") VALUES (" +
                        "?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?" +
                        ")", tableName);
    }

    public String getSelectHistorySqlString(String tableName) {
        return String.format(
                "SELECT execution_id, stage_id, change_id, author, created_at, state, type, invoked_class, invoked_method, source_file, " +
                        "execution_millis, execution_hostname, metadata, system_change, legacy, error_trace, tx_strategy, target_system_id, change_order, recovery_strategy, transaction_flag " +
                        "FROM %s ORDER BY id ASC", tableName);
    }

    private String getAutoIncrementType() {
        switch (sqlDialect) {
            case POSTGRESQL:
                return "BIGSERIAL";
            case SQLITE:
            case H2:
            case DB2:
            case FIREBIRD:
                return "BIGINT GENERATED BY DEFAULT AS IDENTITY";
            case SQLSERVER:
            case SYBASE:
                return "BIGINT IDENTITY(1,1)";
            case ORACLE:
                return "NUMBER GENERATED BY DEFAULT AS IDENTITY";
            case INFORMIX:
                return "SERIAL8";
            case MYSQL:
            case MARIADB:
            default:
                return "BIGINT AUTO_INCREMENT";
        }
    }

    private String getClobType() {
        switch (sqlDialect) {
            case MYSQL:
            case MARIADB:
                return "LONGTEXT";
            case SQLITE:
            case H2:
            case FIREBIRD:
            case INFORMIX:
            case ORACLE:
            case DB2:
                return "CLOB";
            case SQLSERVER:
            case SYBASE:
                return "NVARCHAR(MAX)";
            case POSTGRESQL:
            default:
                return "TEXT";
        }
    }

    private String getBigIntType() {
        switch (sqlDialect) {
            case ORACLE:
                return "NUMBER(19)";
            default:
                return "BIGINT";
        }
    }

    private String getBooleanType() {
        switch (sqlDialect) {
            case MYSQL:
            case MARIADB:
                return "TINYINT(1)";
            case POSTGRESQL:
            case H2:
            case FIREBIRD:
            case INFORMIX:
                return "BOOLEAN";
            case SQLITE:
                return "INTEGER";
            case SQLSERVER:
            case SYBASE:
                return "BIT";
            case ORACLE:
                return "NUMBER(1)";
            default:
                return "SMALLINT";
        }
    }

    public SqlDialect getSqlDialect() {
        return sqlDialect;
    }
}
